/******************************************************************************
Copyright (c) 2008 Drew Benton

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
******************************************************************************/

#ifndef _WINSOCK2API_
	#include <winsock2.h>
#endif

#ifndef _WS2TCPIP_H_
	#include <ws2tcpip.h>
#endif

#ifndef SR33_H_
	#include "SR33.h"
#endif

#ifndef CLIENT_H_
	#include "Client.h"
#endif

#ifndef USERDATA_H
	#include "UserData.h"
#endif

//-----------------------------------------------------------------------------

// Ctor
Client::Client()
{
	// Create CS for login and server injection
	InitializeCriticalSection(&cs);

	// Silkroad proxy object this client belongs to
	proxy = 0;

	// Sockets to maintain
	LocalSocket = INVALID_SOCKET;
	RemoteSocket = INVALID_SOCKET;

	// Port and ip of the client
	port = 0;
	memset(ip, 0, 32);

	// Random number for the client
	dwRandNumber = 0x33;

	// Buffers for the sockets - login
	memset(loginLocalRecvBuffer, 0, 16384);
	memset(loginRemoteRecvBuffer, 0, 16384);
	loginLocalRecvIndex = 0;
	loginRemoteRecvIndex = 0;

	// Login Id assigned
	loginId = 0;

	// Id of server to connect to
	serverId = 0;

	// Allocate memory for user data
	data = new UserData;
}

//-----------------------------------------------------------------------------

// Dtor
Client::~Client()
{
	// Free CSs
	DeleteCriticalSection(&cs);

	// Delete the user data pointer
	delete data;
}

//-----------------------------------------------------------------------------

// Adds a client
void Client::Create(SilkroadProxy * parent, SOCKET local, SOCKET remote)
{
	// Info about the connecting client
	struct sockaddr_in addr = {0};
	socklen_t len = 0;
	char * mip = 0;
	WORD mport = 0;

	// Save the login sockets
	LocalSocket = local;
	RemoteSocket = remote;

	// Get the peer name of the connection
	len = sizeof(addr);
	getpeername(local, (struct sockaddr*)&addr, &len);
	mip = inet_ntoa(addr.sin_addr);
	port = ntohs(addr.sin_port);

	// Save port and ip
	_snprintf(ip, 31, "%s", mip);
	port = mport;

	// Store the parent
	proxy = parent;
}

//-----------------------------------------------------------------------------

// Cleans up the client
void Client::Disconnect()
{
	// Close the sockets
	closesocket(LocalSocket);
	closesocket(RemoteSocket);
	LocalSocket = INVALID_SOCKET;
	RemoteSocket = INVALID_SOCKET;
}

//-----------------------------------------------------------------------------

// Setsup a client
bool Client::Setup(HWND hwnd)
{
	// Error string
	char lastError[4096] = {0};

	// Error variable
	DWORD dwError = 0;

	// Assign network events for the socket to go to the network window
	dwError = WSAAsyncSelect(LocalSocket, hwnd, WM_USER + 1, FD_READ | FD_WRITE | FD_CLOSE);

	// Check for an error
	if(dwError == SOCKET_ERROR)
	{
		// Handle the error
		dwError = WSAGetLastError();
		switch(dwError)
		{
			case WSANOTINITIALISED: _snprintf(lastError, 4095, "A successful WSAStartup call must occur before using this function.\n"); break;
			case WSAENETDOWN: _snprintf(lastError, 4095, "The network subsystem failed.\n"); break;
			case WSAEINVAL: _snprintf(lastError, 4095, "One of the specified parameters was invalid, such as the window handle not referring to an existing window, or the specified socket is in an invalid state.\n"); break;
			case WSAEINPROGRESS: _snprintf(lastError, 4095, "A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.\n"); break;
			case WSAENOTSOCK: _snprintf(lastError, 4095, "The descriptor is not a socket.\n"); break;
			default: _snprintf(lastError, 4095, "Unhandled error: [%i] generated by WSAAsyncSelect.\n", dwError);
		}

		// Log the error
		OnError(lastError);

		// Close the sockets
		closesocket(LocalSocket);
		closesocket(RemoteSocket);

		// Failed to add client
		return false;
	}

	// Set all network events to go to the hwnd
	dwError = WSAAsyncSelect(RemoteSocket, hwnd, WM_USER + 1, FD_READ | FD_CLOSE);
	if(dwError == SOCKET_ERROR)
	{
		// Handle the error
		dwError = WSAGetLastError();
		switch(dwError)
		{
			case WSANOTINITIALISED: _snprintf(lastError, 4095, "A successful WSAStartup call must occur before using this function.\n"); break;
			case WSAENETDOWN: _snprintf(lastError, 4095, "The network subsystem failed.\n"); break;
			case WSAEINVAL: _snprintf(lastError, 4095, "One of the specified parameters was invalid, such as the window handle not referring to an existing window, or the specified socket is in an invalid state.\n"); break;
			case WSAEINPROGRESS: _snprintf(lastError, 4095, "A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.\n"); break;
			case WSAENOTSOCK: _snprintf(lastError, 4095, "The descriptor is not a socket.\n"); break;
			default: _snprintf(lastError, 4095, "Unhandled error: [%i] generated by WSAAsyncSelect.\n", dwError);
		}

		// Log the error
		OnError(lastError);

		// Close the sockets
		closesocket(LocalSocket);
		closesocket(RemoteSocket);

		// Failed to add client
		return false;
	}
	else
	{
		// Set the unique number that the client will set it to
		HandShakeApi.SetRandomNumber(dwRandNumber);
	}

	// Call the user function
	data->OnConnect(this);

	// Success
	return true;
}

//-----------------------------------------------------------------------------

// Called when a socket is ready to have recv called
void Client::OnRead(SOCKET s)
{
	// Should we keep the packet
	bool bKeep = false;

	// Temp pointer to a packet
	tPacket * packet;

	// Recv buffer
	char recvBuffer[8192];
	
	// Recv index
	int recvCount = 0;

	// LoginClient local port
	if(LocalSocket == s)
	{
		// Recv data
		recvCount = recv(LocalSocket, recvBuffer, 8192, 0);

		// Make sure there was not an error
		if(recvCount != SOCKET_ERROR)
		{
			// Copy it into the building buffer
			memcpy(loginLocalRecvBuffer + loginLocalRecvIndex, recvBuffer, recvCount);

			// Increase the index
			loginLocalRecvIndex += recvCount;

			// Two bytes minimal for a packet
			while(loginLocalRecvIndex >= 2)
			{
				// Check to see if we have a packet yet	
				packet = (tPacket*)loginLocalRecvBuffer;

				// Check for encrypted data
				if(packet->size & 0x8000)
				{
					// Real data size
					int realSize = packet->size & 0x7FFF;

					// Actual data size
					int bfSize = HandShakeApi.blowfish.GetOutputLength(realSize + 4);

					// Check to see if we have a complete packet yet
					if(bfSize + 2 <= loginLocalRecvIndex)
					{
						// Copy the packet into the buffer
						memcpy(recvBuffer, loginLocalRecvBuffer, bfSize + 2);

						// Move exising data over
						if(loginLocalRecvIndex - (bfSize + 2))
							memcpy(loginLocalRecvBuffer, loginLocalRecvBuffer + (bfSize + 2), loginLocalRecvIndex - (bfSize + 2));

						// Store the packet pointer
						packet = (tPacket*)recvBuffer;

						// Decrease buffer size
						loginLocalRecvIndex -= (bfSize + 2);

						// Fix the size
						packet->size &= 0x7FFF;

						// Encode the packet
						HandShakeApi.blowfish.Decode((BYTE*)recvBuffer + 2, (BYTE*)recvBuffer + 2, bfSize);

						// Handle the packet
						bKeep = OnClientToServer(packet, true, false);

						// Keep the packet
						if(bKeep == true)
						{
							// Store the final packet size
							realSize = packet->size;

							// Store the new blowfish size
							bfSize = HandShakeApi.blowfish.GetOutputLength(realSize + 4);

							// Mark as encrypted
							packet->size |= 0x8000;

							// Multithread Access
							EnterCriticalSection(&cs);

							// Update recvCount byte
							packet->securityCount = HandShakeApi.GenerateCountByte();

							// Update crc byte
							packet->securityCRC = 0;
							packet->securityCRC = HandShakeApi.GenerateCheckByte(recvBuffer, realSize + 6, HandShakeApi.GetCRCSeed());

							// Multithread Access
							LeaveCriticalSection(&cs);

							// Encode the packet
							HandShakeApi.blowfish.Encode((BYTE*)recvBuffer + 2, (BYTE*)recvBuffer + 2, realSize + 4);

							// Forward the packet
							send(RemoteSocket, recvBuffer, bfSize + 2, 0);
						}
					}
					else
					{
						// No full packet, so break processing and wait for the rest of the data
						break;
					}
				}
				else
				{
					// Check to see if we have a complete packet yet
					if(packet->size + 6 <= loginLocalRecvIndex)
					{
						// Copy the packet into the buffer
						memcpy(recvBuffer, loginLocalRecvBuffer, packet->size + 6);

						// Move exising data over
						if(loginLocalRecvIndex - (packet->size + 6))
							memcpy(loginLocalRecvBuffer, loginLocalRecvBuffer + (packet->size + 6), loginLocalRecvIndex - (packet->size + 6));

						// Store the packet pointer
						packet = (tPacket*)recvBuffer;

						// Decrease buffer size
						loginLocalRecvIndex -= (packet->size + 6);

						// Handle the packet
						bKeep = OnClientToServer(packet, false, false);

						// Keep the packet
						if(bKeep == true)
						{
							// Multithread Access
							EnterCriticalSection(&cs);

							// Update recvCount byte
							packet->securityCount = HandShakeApi.GenerateCountByte();

							// Update crc byte
							packet->securityCRC = 0;
							packet->securityCRC = HandShakeApi.GenerateCheckByte(recvBuffer, packet->size + 6, HandShakeApi.GetCRCSeed());

							// Multithread Access
							LeaveCriticalSection(&cs);

							// Forward the packet
							send(RemoteSocket, recvBuffer, packet->size + 6, 0);
						}
					}
					else
					{
						// No full packet, so break processing and wait for the rest of the data
						break;
					}
				}
			}
		}
	}

	// LoginClient remote port
	else if(RemoteSocket == s)
	{
		// Recv data
		recvCount = recv(RemoteSocket, recvBuffer, 8192, 0);

		// Make sure there was not an error
		if(recvCount != SOCKET_ERROR)
		{
			// Copy it into the building buffer
			memcpy(loginRemoteRecvBuffer + loginRemoteRecvIndex, recvBuffer, recvCount);

			// Increase the index
			loginRemoteRecvIndex += recvCount;

			// Two bytes minimal for a packet
			while(loginRemoteRecvIndex >= 2)
			{
				// Check to see if we have a packet yet	
				packet = (tPacket*)loginRemoteRecvBuffer;

				// Check for encrypted data
				if(packet->size & 0x8000)
				{
					// Real data size
					int realSize = packet->size & 0x7FFF;

					// Actual data size
					int bfSize = HandShakeApi.blowfish.GetOutputLength(realSize + 4);

					// Check to see if we have a complete packet yet
					if(bfSize + 2 <= loginRemoteRecvIndex)
					{
						// Copy the packet into the buffer
						memcpy(recvBuffer, loginRemoteRecvBuffer, bfSize + 2);

						// Move exising data over
						if(loginRemoteRecvIndex - (bfSize + 2))
							memcpy(loginRemoteRecvBuffer, loginRemoteRecvBuffer + (bfSize + 2), loginRemoteRecvIndex - (bfSize + 2));

						// Store the packet pointer
						packet = (tPacket*)recvBuffer;

						// Decrease buffer size
						loginRemoteRecvIndex -= (bfSize + 2);

						// Fix the size
						packet->size &= 0x7FFF;

						// Encode the packet
						HandShakeApi.blowfish.Decode((BYTE*)recvBuffer + 2, (BYTE*)recvBuffer + 2, bfSize);

						// Handle the packet
						bKeep = OnServerToClient(packet, true, false);

						// Keep the packet
						if(bKeep == true)
						{
							// Store the final packet size
							realSize = packet->size;

							// Store the new blowfish size
							bfSize = HandShakeApi.blowfish.GetOutputLength(realSize + 4);

							// Mark as encrypted
							packet->size |= 0x8000;

							// Encode the packet
							HandShakeApi.blowfish.Encode((BYTE*)recvBuffer + 2, (BYTE*)recvBuffer + 2, realSize + 4);

							// Forward the packet
							send(LocalSocket, recvBuffer, bfSize + 2, 0);
						}
					}
					else
					{
						// No full packet, so break processing and wait for the rest of the data
						break;
					}
				}
				else
				{
					// Check to see if we have a complete packet yet
					if(packet->size + 6 <= loginRemoteRecvIndex)
					{
						// Copy the packet into the buffer
						memcpy(recvBuffer, loginRemoteRecvBuffer, packet->size + 6);

						// Move exising data over
						if(loginRemoteRecvIndex - (packet->size + 6))
							memcpy(loginRemoteRecvBuffer, loginRemoteRecvBuffer + (packet->size + 6), loginRemoteRecvIndex - (packet->size + 6));

						// Store the packet pointer
						packet = (tPacket*)recvBuffer;

						// Decrease buffer size
						loginRemoteRecvIndex -= (packet->size + 6);

						// Handle the packet
						bKeep = OnServerToClient(packet, false, false);

						// Keeep the packet
						if(bKeep == true)
						{
							// Forward the packet
							send(LocalSocket, recvBuffer, packet->size + 6, 0);
						}
					}
					else
					{
						// No full packet, so break processing and wait for the rest of the data
						break;
					}
				}
			}
		}
	}
}

//-----------------------------------------------------------------------------

// Returns true of this socket belongs to the client
bool Client::BelongsToClient(SOCKET s)
{
	// Check to see if this socket is the clients
	if(LocalSocket == s || RemoteSocket == s)
		return true;

	// If not, the socket is not ours
	return false;
}

//-----------------------------------------------------------------------------

// Called when a socket is ready to have send called
void Client::OnWrite(SOCKET s)
{
}

//-----------------------------------------------------------------------------

// Called when a socket is closed
void Client::OnDisconnect(SOCKET s)
{
	// Call the user function
	data->OnDisconnect(this);
}

//-----------------------------------------------------------------------------

// Return the port
WORD Client::GetPort() const
{
	return port;
}

//-----------------------------------------------------------------------------

// Return the ip
const char * const Client::GetIp() const
{
	return ip;
}

//-----------------------------------------------------------------------------

// Inject a packet into the login server
void Client::InjectClientToServer(tPacket * packet, bool encrypted)
{
	// Size of the packet
	DWORD realSize = packet->size;

	// Temp buffer
	BYTE tmpBuffer[8192];

	// Copy over the packet to send
	memcpy(tmpBuffer, packet, realSize + 6);
	
	// Make a packet pointer
	tPacket * tmpPacket = (tPacket *) tmpBuffer;

	// Fix the size if it's encrypted
	if(encrypted)
		tmpPacket->size |= 0x8000;

	// Multithread Access
	EnterCriticalSection(&cs);

	// Generate count byte
	tmpPacket->securityCount = HandShakeApi.GenerateCountByte();

	// Generate CRC byte
	tmpPacket->securityCRC = 0;
	tmpPacket->securityCRC = HandShakeApi.GenerateCheckByte((char*)tmpBuffer, realSize + 6, HandShakeApi.GetCRCSeed());

	// Multithread Access
	LeaveCriticalSection(&cs);

	// Check to see if we need to encode the packet
	if(encrypted)
	{
		// Get blowfish data size
		DWORD bfSize = HandShakeApi.blowfish.GetOutputLength(realSize + 4);

		// Encode the packet
		HandShakeApi.blowfish.Encode((BYTE*)tmpBuffer + 2, (BYTE*)tmpBuffer + 2, realSize + 4);

		// Forward the packet
		send(RemoteSocket, (char*)tmpBuffer, bfSize + 2, 0);
	}
	else
	{
		// Forward the packet
		send(RemoteSocket, (char*)tmpBuffer, realSize + 6, 0);
	}

	// Virtually handle the packet
	OnClientToServer(packet, encrypted, true);
}

//-----------------------------------------------------------------------------

// Inject a packet into the client from the login server
void Client::InjectServerToClient(tPacket * packet, bool encrypted)
{
	// Size of the packet
	DWORD realSize = packet->size;

	// Temp buffer
	BYTE tmpBuffer[8192];

	// Copy over the packet to send
	memcpy(tmpBuffer, packet, realSize + 6);
	
	// Make a packet pointer
	tPacket * tmpPacket = (tPacket *)tmpBuffer;

	// Fix the size if it's encrypted
	if(encrypted)
		tmpPacket->size |= 0x8000;

	// Generate count byte
	tmpPacket->securityCount = 0;

	// Generate CRC byte
	tmpPacket->securityCRC = 0;

	// Check to see if we need to encode the packet
	if(encrypted)
	{
		// Get blowfish data size
		DWORD bfSize = HandShakeApi.blowfish.GetOutputLength(realSize + 4);

		// Encode the packet
		HandShakeApi.blowfish.Encode((BYTE*)tmpBuffer + 2, (BYTE*)tmpBuffer + 2, realSize + 4);

		// Forward the packet
		send(LocalSocket, (char*)tmpBuffer, bfSize + 2, 0);
	}
	else
	{
		// Forward the packet
		send(LocalSocket, (char*)tmpBuffer, realSize + 6, 0);
	}

	// Virtually handle the packet
	OnServerToClient(packet, encrypted, true);
}

//-----------------------------------------------------------------------------

// User functions - Packet handler
bool Client::OnClientToServer(tPacket * packet, bool encrypted, bool injected)
{
	// Login packet 1
	if(packet->opcode == 0x6102)
	{
		// Packet reader
		PacketReader reader(packet);

		// Packet data
		BYTE local = 0;
		WORD len = 0;
		char name[32] = {0};
		char pass[32] = {0};
		serverId = 0;

		// Read the packet data
		local = reader.ReadByte();
		len = reader.ReadWord();
		reader.ReadString(len, name);
		len = reader.ReadWord();
		reader.ReadString(len, pass);
		serverId = reader.ReadWord();
	}

	// Pass the packet along
	return data->OnClientToServer(this, packet, encrypted, injected);
}

//-----------------------------------------------------------------------------

// User functions - Packet handler
bool Client::OnServerToClient(tPacket * packet, bool encrypted, bool injected)
{
	// server information
	if(packet->opcode == 0xA102)
	{
		// Packet reader
		PacketReader reader(packet);

		// Get the mode
		BYTE mode = reader.ReadByte();

		// Connection accepted
		if(mode == 1)
		{
			// Id and length
			WORD len = 0;

			// World ip and port to connect to
			char worldIp[32];
			WORD worldPort;

			// Read id
			loginId = reader.ReadDword();

			// Read length of ip
			len = reader.ReadWord();

			// Read the ip
			reader.ReadString(len, worldIp);

			// Read the port
			worldPort = reader.ReadWord();

			// Add a filler world client connection
			proxy->AddPendingClient(loginId, serverId, worldIp, worldPort);
		}
	}

	// Pass the data along to the handshake api
	else if(packet->opcode == 0x5000)
	{
		HandShakeApi.OnPacketRecv((LPBYTE)packet, packet->size + 6);
	}

	// Pass the packet along
	return data->OnServerToClient(this, packet, encrypted, injected);
}

//-----------------------------------------------------------------------------

// The server the client is connected to - 0 if it is a login client
DWORD Client::GetServerId()
{
	return serverId;
}

//-----------------------------------------------------------------------------

// Returns the server name the client is connected to - 
// "" if it is a login client, or "<Unknown>" if the server is not handled
const char * const Client::GetServerName()
{
	// Server string
	static char server[32];

	// Handle the server 
	switch(serverId)
	{
		case 0: strcpy(server, ""); break;
		case 65: _snprintf(server, 31, "%s", "Xian"); break;
		case 74: _snprintf(server, 31, "%s", "Aege"); break;
		case 76: _snprintf(server, 31, "%s", "Troy"); break;
		case 94: _snprintf(server, 31, "%s", "Athens"); break;
		case 96: _snprintf(server, 31, "%s", "Oasis"); break;
		case 102: _snprintf(server, 31, "%s", "Venice"); break;
		case 107: _snprintf(server, 31, "%s", "Greece"); break;
		case 113: _snprintf(server, 31, "%s", "Alps"); break;
		case 114: _snprintf(server, 31, "%s", "Olympus"); break;
		case 132: _snprintf(server, 31, "%s", "Tibet"); break;
		case 134: _snprintf(server, 31, "%s", "Babel"); break;
		case 150: _snprintf(server, 31, "%s", "RedSea"); break;
		case 151: _snprintf(server, 31, "%s", "Rome"); break;
		case 152: _snprintf(server, 31, "%s", "Sparta"); break;
		case 156: _snprintf(server, 31, "%s", "Eldorado"); break;
		case 159: _snprintf(server, 31, "%s", "Pacific"); break;
		case 162: _snprintf(server, 31, "%s", "Alexander"); break;
		case 165: _snprintf(server, 31, "%s", "Persia"); break;
		case 166: _snprintf(server, 31, "%s", "Zeus"); break;
		case 174: _snprintf(server, 31, "%s", "Poseidon"); break;
		case 178: _snprintf(server, 31, "%s", "Hercules"); break;
		case 179: _snprintf(server, 31, "%s", "Odin"); break;
		case 180: _snprintf(server, 31, "%s", "Mercury"); break;
		case 181: _snprintf(server, 31, "%s", "Mars"); break;
		case 182: _snprintf(server, 31, "%s", "Saturn"); break;
		case 183: _snprintf(server, 31, "%s", "Venus"); break;
		case 187: _snprintf(server, 31, "%s", "Uranus"); break;
		case 188: _snprintf(server, 31, "%s", "Pluto"); break;
		case 190: _snprintf(server, 31, "%s", "Neptune"); break;
		case 191: _snprintf(server, 31, "%s", "Hera"); break;
		case 194: _snprintf(server, 31, "%s", "Gaia"); break;
		default: _snprintf(server, 31, "%s", "<Unknown>");
	}

	// Return the server name
	return server;
}

//-----------------------------------------------------------------------------
